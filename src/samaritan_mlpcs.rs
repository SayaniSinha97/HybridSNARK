use ark_poly_commit::kzg10::*;
use ark_poly_commit::error::Error;
use ark_poly::polynomial::Polynomial;
use ark_poly::DenseUVPolynomial;
use ark_poly::evaluations::multivariate::multilinear::MultilinearExtension;
use ark_poly::univariate::DensePolynomial;
use ark_poly::univariate::SparsePolynomial;
use ark_poly::evaluations::multivariate::multilinear::DenseMultilinearExtension;
use ark_ec::pairing::Pairing;
use ark_ff::fields::Field;
use ark_std::{start_timer, end_timer, Zero, One, marker::PhantomData, ops::Div, ops::Mul, ops::Sub};
use ark_std::{UniformRand};
use ark_std::rand::{SeedableRng, RngCore};
use ark_std::rand::rngs::StdRng;
use ark_ff::PrimeField;
use merlin::Transcript;
use ark_ff::BigInteger;
use ark_serialize::CanonicalSerialize;
use ark_poly_commit::PCCommitmentState;
use ark_ec::VariableBaseMSM;
use ark_ec::CurveGroup;
use ark_ec::AffineRepr;
use ark_ec::ScalarMul;
use ark_std::collections::BTreeMap;
use ark_ff::FftField;
use crate::util;
use crate::degree_check::*;

// the structure of SRS for Samaritan multilinear PCS, consists of [g, g\tau, g\tau^2,...] and [h, h\tau, h\tau^2,...], where g and h are random generators of G1 and G2
pub struct SamaritanMLPCS_SRS<E: Pairing> {
    pub(crate) powers_of_g: Vec<E::G1Affine>,
    pub(crate) powers_of_h: Vec<E::G2Affine>,
}

// the structure to hold the proof single evaluation of univariate polynomials using KZG10
pub struct KZG10EvalProof<E: Pairing> {
    proof: E::G1Affine,
}

// the structure of the proof generated by SamaritanMLPCS to prove the evaluation at a point
pub struct SamaritanMLPCSEvalProof<E: Pairing> {
    v_hat_commit: Commitment<E>,
    v_gamma: E::ScalarField,
    p_hat_commit: Commitment<E>,
    b_hat_commit: Commitment<E>,
    u_hat_commit: Commitment<E>,
    t_hat_commit: Commitment<E>,
    q_eval_proof: KZG10EvalProof<E>,
}

pub struct SamaritanMLPCS<E: Pairing>{
    _engine: PhantomData<E>,
}

impl<E: Pairing> SamaritanMLPCS<E>
{
    // setup function that serves both for KZG10 univariate and Samaritan multilinear
    pub fn setup<R: RngCore>(max_vars: usize, rng: &mut R) -> Result<SamaritanMLPCS_SRS<E>, Error> {
        let max_degree = 2usize.pow(max_vars as u32);
        let beta = E::ScalarField::rand(rng);
        let g = E::G1::rand(rng);
        let h = E::G2::rand(rng);

        let mut powers_of_beta = vec![E::ScalarField::one()];
        let mut cur = beta;
        for _ in 0..=max_degree {
            powers_of_beta.push(cur);
            cur *= &beta;
        }

        let powers_of_g = g.batch_mul(&powers_of_beta[0..=max_degree]);
        let powers_of_h = h.batch_mul(&powers_of_beta[0..=max_degree]);

        let pp = SamaritanMLPCS_SRS {
            powers_of_g,
            powers_of_h,
        };
        Ok(pp)
    }

    pub(crate) fn get_univariate_from_multilinear(multi_linear_poly: &DenseMultilinearExtension<E::ScalarField>) -> DensePolynomial<E::ScalarField>{
        DensePolynomial::<E::ScalarField>::from_coefficients_vec(multi_linear_poly.to_evaluations())
    }

    // commit a univariate polynomial w.r.t G1 
    pub fn kzg10_commit_G1(srs: &SamaritanMLPCS_SRS<E>, univ_poly: &DensePolynomial<E::ScalarField>) -> Result<Commitment<E>, Error> {
        let commitment = E::G1::msm(&srs.powers_of_g[..(univ_poly.coeffs().len())], &univ_poly.coeffs()).unwrap().into_affine();
        Ok(Commitment(commitment))
    }

    // commit a multilinear polynomial w.r.t G1, which basically performs commit to univariate polynomial after transformation
    pub fn commit_G1(srs: &SamaritanMLPCS_SRS<E>, multi_linear_poly: &DenseMultilinearExtension<E::ScalarField>) -> Result<Commitment<E>, Error> {
        let univ_poly = Self::get_univariate_from_multilinear(multi_linear_poly);
        let commitment = E::G1::msm(&srs.powers_of_g[..(univ_poly.coeffs().len())], &univ_poly.coeffs()).unwrap().into_affine();
        Ok(Commitment(commitment))
    }

    // prove the evaluation of a univariate polynomial at a single point using KZG10
    pub fn kzg10_eval_prove(srs: &SamaritanMLPCS_SRS<E>, univ_poly: &DensePolynomial<E::ScalarField>, point: E::ScalarField) -> Result<KZG10EvalProof<E>, Error> {
        let divisor = DensePolynomial::<E::ScalarField>::from_coefficients_vec(vec![-point, E::ScalarField::one()]);
        let quotient_poly = (univ_poly - DensePolynomial::<E::ScalarField>::from_coefficients_vec(vec![univ_poly.evaluate(&point)]))/divisor;
        let commitment = E::G1::msm(&srs.powers_of_g[..(quotient_poly.coeffs().len())], &quotient_poly.coeffs()).unwrap().into_affine();
        Ok(KZG10EvalProof{
            proof: commitment
        })
    }

    // verify the evaluation of a polynomial at a single point
    pub fn kzg10_eval_proof_verify(srs: &SamaritanMLPCS_SRS<E>, comm: &Commitment<E>, point: E::ScalarField, eval: E::ScalarField, proof: &KZG10EvalProof<E>) -> Result<bool, Error> {
        let pairing_lhs_first = comm.0 - (srs.powers_of_g[0] * eval);
        let pairing_lhs_second = srs.powers_of_h[0];
        let pairing_rhs_first = proof.proof;
        let pairing_rhs_second = srs.powers_of_h[1] - (srs.powers_of_h[0] * point);
        let pairing_lhs_res = E::pairing(pairing_lhs_first, pairing_lhs_second);
        let pairing_rhs_res = E::pairing(pairing_rhs_first, pairing_rhs_second);
        Ok(pairing_lhs_res == pairing_rhs_res)
    }


    // returns set of mlp evaluations at points where first kappa variables are fixed as in 'point', last nu variables iterates over nu-dimensioanl hypercube
    pub(crate) fn get_evaluation_set(multi_linear_poly: &DenseMultilinearExtension<E::ScalarField>, point: &Vec<E::ScalarField>, kappa: usize, nu: usize) -> Vec<E::ScalarField> {
        let total_vars = kappa + nu;
        let mut evaluations = multi_linear_poly.to_evaluations();
        let sz = evaluations.len();
        for i in 0..kappa {
            for j in (0..sz).step_by(2usize.pow((i+1) as u32)) {
                evaluations[j] = (E::ScalarField::one() - point[i]) * evaluations[j] + point[i] * evaluations[j + 2usize.pow(i as u32)];
            }
        }
        let mut res : Vec<E::ScalarField> = Vec::new();
        for i in (0..2usize.pow(total_vars as u32)).step_by(2usize.pow(kappa as u32)) {
            res.push(evaluations[i]);
        }
        res
    }

    // divide univariate representation of mlp, which is of coeffs size n, into l chunks, each with length m...basically returns g_hat_i(x)'s, for i\in[l] 
    // and each g_hat_i(x) is a (m-1)-degree univariate polynomial
    pub(crate) fn divide_into_univ_polynomial_chunks(univ_poly: &DensePolynomial<E::ScalarField>, m: usize, n: usize) -> Vec<DensePolynomial<E::ScalarField>> {
        let poly_chunks: Vec<_> = univ_poly.coeffs().chunks(m).map(|chunk| DensePolynomial::<E::ScalarField>::from_coefficients_vec(chunk.to_vec())).collect();
        poly_chunks
    }

    // computes p_hat(x), which is linear combination of l univariate polynomials returned by divide_into_univ_polynomial_chunks
    pub(crate) fn linear_combination_of_polynomials(vec_of_univ_poly: &Vec<DensePolynomial<E::ScalarField>>, scalar: E::ScalarField, l: usize) -> DensePolynomial<E::ScalarField> {
        let number_of_polys = vec_of_univ_poly.len();
        let mut res_poly = DensePolynomial::<E::ScalarField>::zero();
        for i in 0..number_of_polys {
            let scalar_i = scalar.pow(&[i as u64]);
            res_poly += (scalar_i, &vec_of_univ_poly[i]);
        }
        res_poly
    }

    #[allow(non_snake_case)]
    pub(crate) fn compute_psi_hat_X_zy(point: &Vec<E::ScalarField>, kappa: usize, nu: usize) -> DensePolynomial<E::ScalarField> 
    where E::ScalarField : FftField {
        let zy: Vec<_> = point[kappa..].to_vec();
        assert_eq!(zy.len(), nu);
        let mut acc = DensePolynomial::<E::ScalarField>::from_coefficients_slice(&[E::ScalarField::one()]);
        for i in 0..nu {
            let mut coeffs = vec![E::ScalarField::zero(); 1 << i];
            coeffs[0] = E::ScalarField::from(zy[i]);
            coeffs.push(E::ScalarField::one() - E::ScalarField::from(zy[i]));

            let term = DensePolynomial::<E::ScalarField>::from_coefficients_vec(coeffs);
            acc = &acc * &term;
        }
        acc
    }

    #[allow(non_snake_case)]
    pub(crate) fn evaluate_psi_hat_X_zy_at_delta(point: &Vec<E::ScalarField>, delta: &E::ScalarField, kappa: usize, nu: usize) -> E::ScalarField {
        let zy: Vec<_> = point[kappa..].to_vec();
        let mut acc = E::ScalarField::one();
        let mut delta_pow = *delta;
        for i in 0..nu {
            acc *= zy[i] + (E::ScalarField::one() - zy[i]) * delta_pow;
            delta_pow *= delta_pow;
        }
        acc
    }

    #[allow(non_snake_case)]
    pub(crate) fn compute_psi_hat_X_zx(point: &Vec<E::ScalarField>, kappa: usize, nu: usize) -> DensePolynomial<E::ScalarField> {
        let zx: Vec<_> = point[..kappa].to_vec();
        assert_eq!(zx.len(), kappa);
        let mut acc = DensePolynomial::<E::ScalarField>::from_coefficients_slice(&[E::ScalarField::one()]);
        for i in 0..kappa {
            let mut coeffs = vec![E::ScalarField::zero(); 1 << i];
            coeffs[0] = E::ScalarField::from(zx[i]);
            coeffs.push(E::ScalarField::one() - E::ScalarField::from(zx[i]));

            let term = DensePolynomial::<E::ScalarField>::from_coefficients_vec(coeffs);
            acc = &acc * &term;
        }
        acc
    }

    pub(crate) fn evaluate_psi_hat_X_zx_at_delta(point: &Vec<E::ScalarField>, delta: &E::ScalarField, kappa: usize, nu: usize) -> E::ScalarField {
        let zx: Vec<_> = point[..kappa].to_vec();
        let mut acc = E::ScalarField::one();
        let mut delta_pow = *delta;
        for i in 0..kappa {
            acc *= zx[i] + (E::ScalarField::one() - zx[i]) * delta_pow;
            delta_pow *= delta_pow;
        }
        acc
    }

    #[allow(non_snake_case)]
    pub(crate) fn compute_phi_hat_X_gamma(gamma: &E::ScalarField, nu: usize) -> DensePolynomial<E::ScalarField> {
        let mut gamma_vec_poly = DensePolynomial::<E::ScalarField>::from_coefficients_slice(&[E::ScalarField::one()]);
        for i in 0..nu {
            let mut coeffs = vec![E::ScalarField::zero(); 1 << i];
            coeffs[0] = gamma.pow(&[2usize.pow(i as u32) as u64]);
            coeffs.push(E::ScalarField::one());

            let term = DensePolynomial::<E::ScalarField>::from_coefficients_vec(coeffs);
            gamma_vec_poly = &gamma_vec_poly * &term;
        }
        gamma_vec_poly
    }

    pub(crate) fn evaluate_phi_hat_X_gamma_at_delta(gamma: &E::ScalarField, delta: &E::ScalarField, nu: usize) -> E::ScalarField {
        let mut acc = E::ScalarField::one();
        let mut delta_pow = *delta;
        let mut gamma_pow = *gamma;
        for i in 0..nu {
            acc *= gamma_pow + delta_pow;
            gamma_pow *= gamma_pow;
            delta_pow *= delta_pow;
        }
        acc
    }

    pub(crate) fn compute_t_hat(v_psi_phi_combined: &DensePolynomial<E::ScalarField>, b_hat: &DensePolynomial<E::ScalarField>, eval: &E::ScalarField, v_gamma: &E::ScalarField, alpha: &E::ScalarField, gamma: &E::ScalarField, p_psi_combined: &DensePolynomial<E::ScalarField>, u_hat: &DensePolynomial<E::ScalarField>, f_hat: &DensePolynomial<E::ScalarField>, p_hat: &DensePolynomial<E::ScalarField>, beta: &E::ScalarField, l: usize, m: usize) -> DensePolynomial<E::ScalarField> {
        let mid_term1 = DensePolynomial::<E::ScalarField>::from_coefficients_vec([vec![E::ScalarField::zero(); l - 1], vec![E::ScalarField::from(*eval + (*alpha * v_gamma))]].concat());
        let mut first_term_in_t_hat = v_psi_phi_combined - &mid_term1 - b_hat;
        if (first_term_in_t_hat.coeffs().len() >= l){
            first_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(first_term_in_t_hat.coeffs()[l..].to_vec());
        }
        else{
            first_term_in_t_hat = DensePolynomial::<E::ScalarField>::zero();
        }

        let mid_term2 = DensePolynomial::<E::ScalarField>::from_coefficients_vec([vec![E::ScalarField::zero(); m - 1], vec![E::ScalarField::from(*v_gamma)]].concat());
        let mut second_term_in_t_hat = (p_psi_combined - &mid_term2 - u_hat) * (*beta);
        if (second_term_in_t_hat.coeffs().len() >= m) {
            second_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(second_term_in_t_hat.coeffs()[m..].to_vec());
        }
        else{
            second_term_in_t_hat = DensePolynomial::<E::ScalarField>::zero();
        }

        let mut third_term_in_t_hat = (f_hat - p_hat) * ((*beta).pow(&[2 as u64]));
        let mut third_term_coeffs = (&third_term_in_t_hat).coeffs.clone();
        for i in (m..third_term_coeffs.len()).rev() {
            let quotient = third_term_coeffs[i];
            third_term_coeffs[i - m] += quotient * gamma;
        }
        third_term_coeffs = third_term_coeffs[m..].to_vec();//  truncate(third_term_coeffs.len() - m);
        third_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(third_term_coeffs);

        let fourth_term_in_t_hat = f_hat * ((*beta).pow(&[3 as u64]));

        let mut fifth_term_in_t_hat = p_hat * ((*beta).pow(&[4 as u64]));
        fifth_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec([vec![E::ScalarField::zero(); (m * l)-m], (&fifth_term_in_t_hat).coeffs().to_vec()].concat());

        let mut sixth_term_in_t_hat = u_hat * ((*beta).pow(&[5 as u64]));
        sixth_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec([vec![E::ScalarField::zero(); (m * l)-m+1], (&sixth_term_in_t_hat).coeffs().to_vec()].concat());

        let mut seventh_term_in_t_hat = b_hat * ((*beta).pow(&[6 as u64]));
        seventh_term_in_t_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec([vec![E::ScalarField::zero(); (m * l)-l+1], (&seventh_term_in_t_hat).coeffs().to_vec()].concat());

        let t_hat = first_term_in_t_hat + second_term_in_t_hat + third_term_in_t_hat + fourth_term_in_t_hat + fifth_term_in_t_hat + sixth_term_in_t_hat + seventh_term_in_t_hat;
        t_hat
    }

    pub(crate) fn compute_q_hat(t_hat: &DensePolynomial<E::ScalarField>, v_hat: &DensePolynomial<E::ScalarField>, psi_hat_X_zy: &DensePolynomial<E::ScalarField>, 
                                phi_hat_X_gamma: &DensePolynomial<E::ScalarField>, psi_hat_X_zx: &DensePolynomial<E::ScalarField>, 
                                b_hat: &DensePolynomial<E::ScalarField>, u_hat: &DensePolynomial<E::ScalarField>, 
                                f_hat: &DensePolynomial<E::ScalarField>, p_hat: &DensePolynomial<E::ScalarField>, 
                                alpha: &E::ScalarField, beta: &E::ScalarField, gamma: &E::ScalarField, delta: &E::ScalarField, delta_inverse: &E::ScalarField, 
                                v: &E::ScalarField, v_gamma: &E::ScalarField, l: usize, m: usize) -> DensePolynomial<E::ScalarField> {
        let psi_hat_X_zy_at_delta = psi_hat_X_zy.evaluate(delta);
        let phi_hat_X_gamma_at_delta = phi_hat_X_gamma.evaluate(delta);
        let psi_hat_X_zx_at_delta = psi_hat_X_zx.evaluate(delta);

        let first_term_in_q_hat = t_hat;

        let multiplier1 = E::ScalarField::from(delta_inverse.pow(&[l as u64]));
        let second_term_in_q_hat = (v_hat * (psi_hat_X_zy_at_delta + phi_hat_X_gamma_at_delta * alpha) - b_hat - DensePolynomial::<E::ScalarField>::from_coefficients_vec(vec![E::ScalarField::from((delta.pow(&[(l-1) as u64])) * (*v + (*alpha) * v_gamma))])) * (multiplier1);
        
        let multiplier2 = E::ScalarField::from(delta_inverse.pow(&[m as u64]));
        let third_term_in_q_hat = (p_hat * (psi_hat_X_zx_at_delta) - u_hat - DensePolynomial::<E::ScalarField>::from_coefficients_vec(vec![E::ScalarField::from(*v_gamma * (delta.pow(&[(m-1) as u64])))])) * (multiplier2 * *beta);
        
        let multiplier3 = (delta.pow(&[m as u64]) - gamma).inverse().unwrap();
        let fourth_term_in_q_hat = (f_hat - p_hat) * (beta.pow(&[2 as u64])) * multiplier3;

        let fifth_term_in_q_hat = f_hat * (beta.pow(&[3 as u64]));

        let sixth_term_in_q_hat = p_hat * (beta.pow(&[4 as u64]) * delta.pow(&[((l*m)-m) as u64]));

        let seventh_term_in_q_hat = u_hat * (beta.pow(&[5 as u64]) * delta.pow(&[((l*m)-m+1) as u64]));

        let eighth_term_in_q_hat = b_hat * (beta.pow(&[6 as u64]) * delta.pow(&[((l*m)-l+1) as u64]));

        let q_hat = first_term_in_q_hat - (second_term_in_q_hat + third_term_in_q_hat + fourth_term_in_q_hat + fifth_term_in_q_hat + sixth_term_in_q_hat + seventh_term_in_q_hat + eighth_term_in_q_hat);
        q_hat
    }

    // verifier computes q_hat_commit from existing commitments (sent by prover) using homomorphic property of underlying kzg10
    pub(crate) fn compute_q_hat_commit(g: E::G1Affine, t_hat_commit: &Commitment<E>, v_hat_commit: &Commitment<E>, p_hat_commit: &Commitment<E>, b_hat_commit: &Commitment<E>, u_hat_commit: &Commitment<E>, mlp_comm: &Commitment<E>, psi_hat_X_zy_at_delta: E::ScalarField, phi_hat_X_gamma_at_delta: E::ScalarField, psi_hat_X_zx_at_delta: E::ScalarField, alpha: &E::ScalarField, beta: &E::ScalarField, gamma: &E::ScalarField, delta: &E::ScalarField, delta_inverse: &E::ScalarField, v: &E::ScalarField, v_gamma: &E::ScalarField, l: usize, m: usize) -> Commitment<E> {
        let commit_terms : Vec<E::G1Affine> = vec![t_hat_commit.0, v_hat_commit.0, g, b_hat_commit.0, p_hat_commit.0, g, u_hat_commit.0, mlp_comm.0, p_hat_commit.0, mlp_comm.0, p_hat_commit.0, u_hat_commit.0, b_hat_commit.0]; 
        
        let mut scalar_terms = vec![E::ScalarField::one(); 13];
        scalar_terms[1] = - (psi_hat_X_zy_at_delta + (*alpha * phi_hat_X_gamma_at_delta)) * E::ScalarField::from(delta_inverse.pow(&[l as u64]));
        scalar_terms[2] = (*v + (*alpha * v_gamma)) * E::ScalarField::from(*delta_inverse);
        scalar_terms[3] = E::ScalarField::from(delta_inverse.pow(&[l as u64]));
        scalar_terms[4] = - (psi_hat_X_zx_at_delta * beta) * E::ScalarField::from(delta_inverse.pow(&[m as u64]));
        scalar_terms[5] = (*beta * v_gamma) * E::ScalarField::from(*delta_inverse);
        scalar_terms[6] = *beta * E::ScalarField::from(delta_inverse.pow(&[m as u64]));
        scalar_terms[7] = - (beta.pow(&[2 as u64])) * (E::ScalarField::from(delta.pow(&[m as u64])-gamma).inverse().unwrap());
        scalar_terms[8] = - scalar_terms[7];
        scalar_terms[9] = - (beta.pow(&[3 as u64]));
        scalar_terms[10] = - (beta.pow(&[4 as u64])) * (delta.pow(&[((l*m)-m) as u64]));
        scalar_terms[11] = - (beta.pow(&[5 as u64])) * (delta.pow(&[((l*m)-m+1) as u64]));
        scalar_terms[12] = - (beta.pow(&[6 as u64])) * (delta.pow(&[((l*m)-l+1) as u64]));

        let res = E::G1::msm(&commit_terms, &scalar_terms).unwrap().into_affine();
        let output : Commitment<E> = Commitment(res);
        output
    }

    pub fn prove(
        srs: &SamaritanMLPCS_SRS<E>,
        multi_linear_poly: &DenseMultilinearExtension<E::ScalarField>,
        point: &Vec<E::ScalarField>,
        eval: E::ScalarField,
        rng: &mut dyn RngCore,
    ) -> Result<(SamaritanMLPCSEvalProof<E>, DegreeCheckPolynomials<E>), Error> {
        let prover_time = start_timer!(|| format!("SamaritanMLPCS::prove with multilinear polynomial of maximum variables {}", multi_linear_poly.num_vars));

        let seed = [42u8; 32];
        let mut rng2 = StdRng::from_seed(seed);

        let mu: usize = multi_linear_poly.num_vars;
        let kappa = (mu as f64).log2().round() as i32;
        let nu: i32 = (mu as i32) - kappa;
        let n: usize = 2usize.pow(mu as u32);
        let m: usize = 2usize.pow(kappa as u32);
        let l: usize = 2usize.pow(nu as u32);
        let max_deg: usize = n;

        // println!("mu: {}, kappa: {}, nu: {}, n: {}, m: {}, l: {}, max_deg: {}, multi_linear_poly size: {}", mu, kappa, nu, n, m, l, max_deg, multi_linear_poly.to_evaluations().to_vec().len());

        let f_hat = Self::get_univariate_from_multilinear(&multi_linear_poly);

        let mut transcript = Transcript::new(b"SamaritanMLPCS Transcript");

        //the v_i's, where v_i = g_i(z_x) = f(z_x, <i>) for all i\in[l]
        let g_evaluation_values: Vec<_> = Self::get_evaluation_set(&multi_linear_poly, &point, kappa as usize, nu as usize);

        //the polynomial v(x)=\sum_{i=1}^l X^{i-1}v_i
        let v_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(g_evaluation_values);

        //commit to v(x)
        let v_hat_commit = SamaritanMLPCS::<E>::kzg10_commit_G1(&srs, &v_hat).unwrap();

        util::append_commitment_to_transcript::<E>(&mut transcript, b"v_hat_commit", &v_hat_commit);

        //choosing a random field element \gamma, supposed to be verifier's choice, will edit the code to emulate RO behaviour to generate it from H(transcript till the point) 
        let gamma = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"gamma");

        //compute v_gamma = v(\gamma)
        let v_gamma = v_hat.evaluate(&gamma);
        util::append_field_element_to_transcript::<E>(&mut transcript, b"v_gamma", &v_gamma);

        // divide the univariate polynomial into multiple chunks and return those chunks as vectors of univariate polynomials
        let all_gxs: Vec<_> = Self::divide_into_univ_polynomial_chunks(&f_hat, m, n);

        // linearly combine those small univariate polynomials 
        let p_hat = Self::linear_combination_of_polynomials(&all_gxs, gamma, l);

        // commit to linearly_combined_poly, p_hat(x) = \sum_{i=1}^l\gamma^{i-1}g_i(x)
        let p_hat_commit = SamaritanMLPCS::<E>::kzg10_commit_G1(&srs, &p_hat).unwrap();

        util::append_commitment_to_transcript::<E>(&mut transcript, b"p_hat_commit", &p_hat_commit);

        #[allow(non_snake_case)]
        let psi_hat_X_zy = Self::compute_psi_hat_X_zy(&point, kappa as usize, nu as usize);

        #[allow(non_snake_case)]
        let phi_hat_X_gamma = Self::compute_phi_hat_X_gamma(&gamma, nu as usize);

        let alpha = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"alpha");

        // v_psi_phi_combined = v * (psi + (alpha * phi))
        let v_psi_phi_combined = &v_hat * (&psi_hat_X_zy + (&phi_hat_X_gamma) * alpha);

        // extract necessary (l-1) terms in b_hat
        let mut b_hat = DensePolynomial::<E::ScalarField>::zero();
        if (v_psi_phi_combined.coeffs().len() >= l-1) {
            let least_coeffs = v_psi_phi_combined.coeffs()[..(l-1)].to_vec();
            b_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(least_coeffs);
        }

        // compute commitment to b_hat
        let b_hat_commit = SamaritanMLPCS::<E>::kzg10_commit_G1(&srs, &b_hat).unwrap();
        util::append_commitment_to_transcript::<E>(&mut transcript, b"b_hat_commit", &b_hat_commit);

        // compute psi_hat(X;zx)
        #[allow(non_snake_case)]
        let psi_hat_X_zx = Self::compute_psi_hat_X_zx(&point, kappa as usize, nu as usize);

        // compute p_hat(x) * psi_hat(X;zx)
        let p_psi_combined = &p_hat * &psi_hat_X_zx;

        // extract necessary (m-1) number of terms in u_hat
        let mut u_hat = DensePolynomial::<E::ScalarField>::zero();
        if (p_psi_combined.coeffs().len() >= m-1) {
            let selected_coeffs = p_psi_combined.coeffs()[..(m - 1)].to_vec();
            u_hat = DensePolynomial::<E::ScalarField>::from_coefficients_vec(selected_coeffs);
        }

        let u_hat_commit = SamaritanMLPCS::<E>::kzg10_commit_G1(&srs, &u_hat).unwrap();
        util::append_commitment_to_transcript::<E>(&mut transcript, b"u_hat_commit", &u_hat_commit);

        let beta = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"beta");

        let t_hat = Self::compute_t_hat(&v_psi_phi_combined, &b_hat, &eval, &v_gamma, &alpha, &gamma, &p_psi_combined, &u_hat, &f_hat, &p_hat, &beta, l, m);
        let t_hat_commit = SamaritanMLPCS::<E>::kzg10_commit_G1(&srs, &t_hat).unwrap();
        util::append_commitment_to_transcript::<E>(&mut transcript, b"t_hat_commit", &t_hat_commit);

        let delta = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"delta");
        let delta_inverse = delta.inverse().unwrap();

        let q_hat = Self::compute_q_hat(&t_hat, &v_hat, &psi_hat_X_zy, &phi_hat_X_gamma, &psi_hat_X_zx, &b_hat, &u_hat, &f_hat, &p_hat, &alpha, &beta, &gamma, &delta, &delta_inverse, &eval, &v_gamma, l, m);

        let q_eval_proof = SamaritanMLPCS::<E>::kzg10_eval_prove(&srs, &q_hat, delta).unwrap();
        end_timer!(prover_time);
        
        let proof = SamaritanMLPCSEvalProof {
            v_hat_commit: v_hat_commit, 
            v_gamma: v_gamma, 
            p_hat_commit: p_hat_commit, 
            b_hat_commit: b_hat_commit, 
            u_hat_commit: u_hat_commit, 
            t_hat_commit: t_hat_commit, 
            q_eval_proof: q_eval_proof
        };

        let deg_check = DegreeCheckPolynomials {
            polys: vec![t_hat],
            degs: vec![n - 1],
        };

        Ok((proof, deg_check))
    }

    pub fn verify(
        srs: &SamaritanMLPCS_SRS<E>,
        mlp_comm: &Commitment<E>,
        point: &Vec<E::ScalarField>,
        value: E::ScalarField,
        proof: &SamaritanMLPCSEvalProof<E>,
    ) -> Result<bool, Error> {
        let mu: usize = point.len();
        let kappa = (mu as f64).log2().round() as i32;
        let nu: i32 = (mu as i32)- kappa;
        let n: usize = 2usize.pow(mu as u32);
        let m: usize = 2usize.pow(kappa as u32);
        let l: usize = 2usize.pow(nu as u32);
        let max_deg: usize = n;

        let verifier_time = start_timer!(|| format!("SamaritanMLPCS::verify with multilinear polynomial"));
        
        let mut transcript = Transcript::new(b"SamaritanMLPCS Transcript");

        util::append_commitment_to_transcript::<E>(&mut transcript, b"v_hat_commit", &proof.v_hat_commit);

        let gamma = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"gamma");

        util::append_field_element_to_transcript::<E>(&mut transcript, b"v_gamma", &proof.v_gamma);
        util::append_commitment_to_transcript::<E>(&mut transcript, b"p_hat_commit", &proof.p_hat_commit);

        let alpha = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"alpha");

        util::append_commitment_to_transcript::<E>(&mut transcript, b"b_hat_commit", &proof.b_hat_commit);
        util::append_commitment_to_transcript::<E>(&mut transcript, b"u_hat_commit", &proof.u_hat_commit);

        let beta = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"beta");

        util::append_commitment_to_transcript::<E>(&mut transcript, b"t_hat_commit", &proof.t_hat_commit);
        // util::append_commitment_to_transcript::<E>(&mut transcript, b"s_hat_commit", &proof.s_hat_commit);

        let delta = util::sample_random_challenge_from_transcript::<E>(&mut transcript, b"delta");
        let delta_inverse = delta.inverse().unwrap();

        let psi_hat_X_zy_at_delta = Self::evaluate_psi_hat_X_zy_at_delta(&point, &delta, kappa as usize, nu as usize);
        let phi_hat_X_gamma_at_delta = Self::evaluate_phi_hat_X_gamma_at_delta(&gamma, &delta, nu as usize);
        let psi_hat_X_zx_at_delta = Self::evaluate_psi_hat_X_zx_at_delta(&point, &delta, kappa as usize, nu as usize);

        let q_hat_commit = Self::compute_q_hat_commit(srs.powers_of_g[0], &proof.t_hat_commit, &proof.v_hat_commit, &proof.p_hat_commit, &proof.b_hat_commit, &proof.u_hat_commit, &mlp_comm, psi_hat_X_zy_at_delta, phi_hat_X_gamma_at_delta, psi_hat_X_zx_at_delta, &alpha, &beta, &gamma, &delta, &delta_inverse, &value, &proof.v_gamma, l, m);
        
        let passed = SamaritanMLPCS::<E>::kzg10_eval_proof_verify(&srs, &q_hat_commit, delta, E::ScalarField::zero(), &proof.q_eval_proof).unwrap();

        Ok(passed == true)
    }
}

#[cfg(test)]
mod tests {
    // #![allow(non_camel_case_types)]
    use ark_poly_commit::kzg10::*;
    use ark_poly_commit::*;
    use ark_ec::pairing::Pairing;
    // use ark_bls12_381::Bls12_381;
    // use ark_bls12_381::Fr;
    use ark_bn254::Bn254;
    use ark_bn254::Fr;
    use ark_std::test_rng;
    use crate::samaritan_mlpcs::*;

    // type SamaritanMLPCS_Bls12_381 = SamaritanMLPCS<Bls12_381>;
    type SamaritanMLPCS_Bn254 = SamaritanMLPCS<Bn254>;

    #[test]
    fn functionality_test() {

        /* Below commented lines are just to check the order of coefficients expected in the polynomial. The univariate polynomial my_poly constructed from vector 
            [2,1,5,3] is basically 2 + x + 5x^2 + 3x^3; and hence it correctly gets evaluated to value 48, at point x = 2. 
            This is not directly related to Samaritan, but for a sanity check of arkworks DensePolynomial functionality. */
        // let coeffs = vec![Fr::from(2 as u64), Fr::from(1 as u64), Fr::from(5 as u64), Fr::from(3 as u64)];
        // let my_poly = DensePolynomial::<Fr>::from_coefficients_vec(coeffs);
        // let value = my_poly.evaluate(&Fr::from(2 as u64));
        // assert_eq!(value, Fr::from(48 as u64));

        /* the test starts. */

        let mut rng = &mut test_rng();
        let num_vars = 18;
        let mlp = DenseMultilinearExtension::rand(num_vars, rng);
        // println!("mlp: {:?}", mlp);

        //===============================================

        // // the setup of SamaritanMLPCS
        // let srs = SamaritanMLPCS_Bls12_381::setup(num_vars, &mut rng).unwrap();

        // // the commit of SamaritanMLPCS: commit to multilinear polynomial mlp, viewed as univariate polynomial f_hat, f_hat_commit is output by it.
        // let comm = SamaritanMLPCS_Bls12_381::commit_G1(&srs, &mlp).unwrap();

        // // sampling a random point (basically mu number of field elements for mu-variate multilinear polynomial) and evaluate the polynomial at that point
        // let point: Vec<_> = (0..num_vars).map(|_| Fr::rand(rng)).collect();

        // let eval = mlp.evaluate(&point);

        // // println!("At point: {:?}, eval is: {:?}", point, eval);
                
        // // run the interactive prover of SamaritanMLPCS to do a proof of evaluation to show mlp(point) = eval 
        // let (eval_proof, deg_check) = SamaritanMLPCS_Bls12_381::prove(&srs, &mlp, &point, eval, &mut rng).expect("something went wrong in proving");

        // // run the interactive verifier of SamaritanMLPCS to verify the proof of mlp(point) = eval
        // let valid = SamaritanMLPCS_Bls12_381::verify(&srs, &comm, &point, eval, &eval_proof).unwrap();
        
        // assert_eq!(valid, true);

        // let deg_check_proof = DegreeCheck::<Bls12_381>::prove(&srs, &deg_check).unwrap();
        // let valid_deg_check = DegreeCheck::<Bls12_381>::verify(&srs, &deg_check_proof).unwrap();

        // assert_eq!(valid_deg_check, true);

        //==================================================

        // the setup of SamaritanMLPCS
        let srs = SamaritanMLPCS_Bn254::setup(num_vars, &mut rng).unwrap();

        // the commit of SamaritanMLPCS: commit to multilinear polynomial mlp, viewed as univariate polynomial f_hat, f_hat_commit is output by it.
        let comm = SamaritanMLPCS_Bn254::commit_G1(&srs, &mlp).unwrap();

        // sampling a random point (basically mu number of field elements for mu-variate multilinear polynomial) and evaluate the polynomial at that point
        let point: Vec<_> = (0..num_vars).map(|_| Fr::rand(rng)).collect();

        let eval = mlp.evaluate(&point);

        // println!("At point: {:?}, eval is: {:?}", point, eval);
                
        // run the interactive prover of SamaritanMLPCS to do a proof of evaluation to show mlp(point) = eval 
        let (eval_proof, deg_check) = SamaritanMLPCS_Bn254::prove(&srs, &mlp, &point, eval, &mut rng).expect("something went wrong in proving");

        // run the interactive verifier of SamaritanMLPCS to verify the proof of mlp(point) = eval
        let valid = SamaritanMLPCS_Bn254::verify(&srs, &comm, &point, eval, &eval_proof).unwrap();
        
        assert_eq!(valid, true);

        let deg_check_proof = DegreeCheck::<Bn254>::prove(&srs, &deg_check).unwrap();
        let valid_deg_check = DegreeCheck::<Bn254>::verify(&srs, &deg_check_proof).unwrap();

        assert_eq!(valid_deg_check, true);
    }

}